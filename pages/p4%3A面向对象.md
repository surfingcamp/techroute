title:: p4:面向对象

- title:: p4:面向对象
- > 直接照着例子先写代码运行出来 再来理解面向对象理论会更容易懂一些
- # 成员变量
- 写一段代码来理解成员变量  构造函数 this变量
- # 方法
- 静态方法
  collapsed:: true
	- 什么时候使用静态方法 #card
		- 我没必要创建一个对象来调用一个方法，不同对象被继承 方法里不需要用到成员变量（每个对象有自己的成员变量），比如工具类参考PointUtils并且把构造方法变成私有的了[[$blue]]==【video:20210926:面向对象:11min】==
- 通过一段代码来理解一个面向对象方法块，静态方法块、静态成员、对象成员的执行顺序
- 方法的权限
	- 子类不能降低父类的权限，比如父类是protocted子类不能是private不然会报错，为什么？ #card
- TODO 方法重载
	- 重载和重写
		- 重载是新增加一个方法，参数和访问修饰符都可以变
		- 重写是在子类覆盖父类方法
			- 重写的时候为什么不能够把访问修饰符变低，因为以后会写Father f= new Son(); f.buyDog();如果buyDog()在子类是private方法你编译没错但是运行时没有权限访问的。
			- 重写的时候返回值可以是子类但是参数必须是一模一样[[$blue]]==【video:20210926面向对象:1h:28min】==
	- 多态
	  collapsed:: true
		- 虽然`CutMan m1 = new Baber()`但是真实类型是Baber通过debug可以看出
		- 为什么写代码是基于抽象来写[[$blue]]==【video:20210928面向对象:26min】==
		- 多态为什么`CutMan m1 = new Baber()`真正调用的时候指向的是子类，解释重写了就调用子类的，参考[[$blue]]==【video:20210928面向对象:44min】==
		- 强制转型要通过instance加判断[[$blue]]==【video:20210928面向对象:1h2min】==
- 面向对象多态
	- 继承
	  collapsed:: true
		- 为什么要继承 #card
			- 我要写方法，不要把所有逻辑都写一遍复用父类的代码
	- 一般设计，如果重写就调用重写方法，没有重写就调用父类的方法
		- 这怎么做到的（为什么可以做到，这个很深刻不理解）
	- instance of因为多态我要判断一个对象具体什么类型
		- 写个代码对instance of 理解加深
	- 封装
	-
- final static
  > 从java 基础语法 理解final static就可以
- 接口 ：
  id:: 63212040-e982-47f3-84bb-a3d759a89b1e
  collapsed:: true
	- 为什么要用接口 #card
		- 提供公共的接口能力，如果想要有某个能力就实现对应接口就可以，提供规范和能力
			- 想一下如果你写了一个IFly接口(有一个方法 IFly.fly()方法)，但是你定义一个Bird类如果没有实现IFly接口那么就不会实现fly()方法，那么别人调用Bird对象方法就没有fly()方法。当然你也可以自己在Bird类里写一个但是实际工作中都是使用父类指针指向子类即一般是IFly bird = new Bird()这样来写，这代表我现在这个bird变量指向堆里的new Bird()我有fly()的能力。一般是使用什么接口就用对应接口指向Bird()子类。
		- 接口只是定义了一个能力，告诉别人我有这个能力。至于这个能力怎么实现通过类实现
	- 特征：
		- 可以多继承，我想要多个能力可以实现多个接口
	- 至于接口一些特性不用记的，比如接口是否可以继承接口
		- 可以这么理解比如我要复用能力，肯定可以继承
- 内部类
  collapsed:: true
	- 为什么有内部类呢？ #card
		- 我我只想被这个外部类访问的时候直接定义成这个外部类的内部类，这样封装性更好
	- 匿名内部类：如果定义的类只被用一次就不用定义这个类
	  > Outer$Inner.class
	- 应用：ArrayList和LinkedList源码里用到了内部类
	  `private class Itr implements Iterator<E>`，ArrayList和LinkedList调用Itr的next方法实现不一样，所以这个通过在ArrayList和LinkedList单独定义一个内部类来实现。ArrayList里的Itr只被ArrayList来使用
	- 具体使用：内部类是外部类一个成员，所以可以在外部类方法中实例化但是不能够被外界实例化[[$blue]]==【video:20210930面向对象1h:24min】==
	- 内部类私有会怎么样，private class Inner，在Demo.java类里是不能Outer.Inner这样来访问的
	- 内部类可以访问外部类的成员[[$blue]]==【video:20210930面向对象1h:37min】==
		- 在内部类不需要Outer.this.name这样方式来写
	- 查看内部类编译后的class情况 Outer.class/Outer$Inner.class
- 抽象类：
  collapsed:: true
	- 写法:  abstract class
	- 为什么有抽象类 #card
		- 不想实例化的类但是想被子类继承利用抽象类就是一个模板
		  > 比如Animal不能被实例化但是 默认动作被Dog继承使用
- 写了面向对象例子后：在写代码时候，面向对象与面向过程区别 #card
	- 面向过程我会把一个任务拆分很多步骤（写到很多方法里）而面向对象就是设计出对象和对应方法和成员，通过调用对象方法来触发行为
		- 解释面向过程写法：[[$blue]]==【video:20210923面向过程:6min】==
		  > 面向过程各个函数设计到全局变量这些全局变量怎么管理是一个工程问题但是比面向对象要复杂
		- 解释面向对象写法：[[$blue]]==【video:20210923面向对象:6min54s】==
- 解释一下面向对象程序执行过程中内存中数据怎么存储的程序如何执行的[[$blue]]==【video:20210923面向对象:40min】==
- 解释一下传值和传引用的区别[[$blue]]==【video:20210923面向对象:1h:05min】==
  > 本质传值的时候对应变量是放在栈上而对象是传的是引用方法调用拿的是堆中对象的地址，基本数据类型为什么传值因为基本数据类型存放在栈里的
	- 值传递：栈里面的运行完就释放了所以还是原来的
	- 传引用：可以debug看下对象地址是不是同一个也可以确认
- 匿名对象：因为没有变量指向所以当只想使用一次的时候就使用匿名对象
- 面向对象理解：
	- 怎么理解封装：[[$blue]]==【video:20210923面向对象:1h:29min】==
- 为什么会有this指针：参考[[$blue]]==【video:20210923面向对象:1h:38min】==
- 构造函数，参考[[$blue]]==【video:20210923面向对象:1h:43min】==
	- 有人以为 执行 `new Department(){ this(id);}`会创建两个对象，我们可以在这两个构造函数打断点确认这两个构造函数对应地址是否是同一个
		- 结论：当我们执行new的时候其实已经把空间开辟出来了只不过调用构造函数进行成员变量的初始化，这个让我想起了volatile防止半对象问题也涉及到 开辟空间和初始化
- 静态代码块，构造代码块和构造方法执行顺序，参考[[$blue]]==【video:20210926面向对象:22min】==
	- 类只有用到的时候才加载，利用class.forName()来验证
- TODO 一个包下面不能有相同的类
  > 不管哪个类是不是内部类[[$blue]]==【video:20210926面向对象:37min】== ，看一下内部类输出的package结果
	- 默认包是无法导入的[[$blue]]==【video:20210926面向对象:41min】==
		- java.lang包不用导入
- 构造函数写法和使用：
	- 不用写super默认也会调用父类构造函数
	  > 注意普通方法override的不写super不会默认调用父类方法
		- 如果定义了有参数会覆盖无参数的，除非你自己显示写一个无参的
- 父类属性在子类中可见问题
	- 根据权限public private protected可见度不一样
		- 比如没写任何package权限，放到不同包就没有了
	- protected不管在不在不同包都是可见的
	- 如果父类和子类都有相同属性呢？
- 抽象类：为什么有抽象类
	- 有一些类不想被实例化
- 接口：为什么定义接口
	- TODO 可以多继承，参考【code:oop06/OOPDemo03】，规范以IXXX来命名接口，实现一个接口表示你具有什么样的能力。你使用什么接口来接收就只能看到这个接口对应的能力。（ 完善代码类）
	- 基于抽象和接口编程：方法参数等应该是一个接口，参考[[$blue]]==【video:20210930面向对象:1h