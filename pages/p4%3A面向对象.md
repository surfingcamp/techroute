title:: p4:面向对象

- title:: p4:面向对象
- > 直接照着例子先写代码运行出来 再来理解面向对象理论会更容易懂一些
- 写一段代码来理解成员变量  构造函数 this变量
- 静态方法
	- 什么时候使用静态方法 #card
		- 我没必要创建一个对象来调用一个方法，不同对象被继承 方法里不需要用到成员变量（每个对象有自己的成员变量）
- 通过一段代码来理解一个面向对象方法块，静态方法块、静态成员、对象成员的执行顺序
- 方法的权限
	- 子类不能降低父类的权限，比如父类是protocted子类不能是private不然会报错，为什么？ #card
- 面向对象多态
	- 继承
		- 为什么要继承 #card
			- 我要写方法，不要把所有逻辑都写一遍复用父类的代码
	- 一般设计，如果重写就调用重写方法，没有重写就调用父类的方法
		- 这怎么做到的（为什么可以做到，这个很深刻不理解）
	- instance of因为多态我要判断一个对象具体什么类型
		- 写个代码对instance of 理解加深
- final static
  > 从java 基础语法 理解final static就可以
- 接口 ：
  id:: 63212040-e982-47f3-84bb-a3d759a89b1e
	- 为什么要用接口 #card
		- 提供公共的接口能力，如果想要有某个能力就实现对应接口就可以，提供规范和能力
			- 想一下如果你写了一个IFly接口(有一个方法 IFly.fly()方法)，但是你定义一个Bird类如果没有实现IFly接口那么就不会实现fly()方法，那么别人调用Bird对象方法就没有fly()方法。当然你也可以自己在Bird类里写一个但是实际工作中都是使用父类指针指向子类即一般是IFly bird = new Bird()这样来写，这代表我现在这个bird变量指向堆里的new Bird()我有fly()的能力。一般是使用什么接口就用对应接口指向Bird()子类。
		- 接口只是定义了一个能力，告诉别人我有这个能力。至于这个能力怎么实现通过类实现
	- 特征：
		- 可以多继承，我想要多个能力可以实现多个接口
	- 至于接口一些特性不用记的，比如接口是否可以继承接口
		- 可以这么理解比如我要复用能力，肯定可以继承
- 内部类
	- 为什么有内部类呢？ #card
		- 我我只想被这个外部类访问的时候直接定义成这个外部类的内部类，这样封装性更好
	- 匿名内部类：如果定义的类只被用一次就不用定义这个类
	  > Outer$Inner.class
	- 应用：ArrayList和LinkedList源码里用到了内部类
	  `private class Itr implements Iterator<E>`，ArrayList和LinkedList调用Itr的next方法实现不一样，所以这个通过在ArrayList和LinkedList单独定义一个内部类来实现。ArrayList里的Itr只被ArrayList来使用
- 抽象类：
	- 写法:  abstract class
	- 为什么有抽象类 #card
		- 不想实例化的类但是想被子类继承利用抽象类就是一个模板
		  > 比如Animal不能被实例化但是 默认动作被Dog继承使用
- 写了面向对象例子后：在写代码时候，面向对象与面向过程区别 #card
	- 面向过程我会把一个任务拆分很多步骤（写到很多方法里）而面向对象就是设计出对象和对应方法和成员，通过调用对象方法来触发行为
		- 解释面向过程写法：[[$blue]]==【video:20210923面向过程:6min】==
		  > 面向过程各个函数设计到全局变量这些全局变量怎么管理是一个工程问题但是比面向对象要复杂
		- 解释面向对象写法：[[$blue]]==【video:20210923面向对象:6min54s】==
- 解释一下面向对象程序执行过程中内存中数据怎么存储的程序如何执行的[[$blue]]==【video:20210923面向对象:40min】==
- 解释一下传值和传引用的区别[[$blue]]==【video:20210923面向对象:1h:05min】==
  > 本质传值的时候对应变量是放在栈上而对象是传的是引用方法调用拿的是堆中对象的地址，基本数据类型为什么传值因为基本数据类型存放在栈里的
	- 值传递：栈里面的运行完就释放了所以还是原来的
	- 传引用：可以debug看下对象地址是不是同一个也可以确认
- 匿名对象：因为没有变量指向所以当只想使用一次的时候就使用匿名对象
- 面向对象理解：
	- 怎么理解封装：[[$blue]]==【video:20210923面向对象:1h:29min】==
- 为什么会有this指针：参考[[$blue]]==【video:20210923面向对象:1h:38min】==
- 构造函数，参考[[$blue]]==【video:20210923面向对象:1h:43min】==
	- 有人以为 执行 `new Department(){ this(id);}`会创建两个对象，我们可以在这两个构造函数打断点确认这两个构造函数对应地址是否是同一个
		- 结论：当我们执行new的时候其实已经把空间开辟出来了只不过调用构造函数进行成员变量的初始化，这个让我想起了volatile防止半对象问题也涉及到 开辟空间和初始化