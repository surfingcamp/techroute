- 七大原则
	- 对修改封闭对增加开放原则
	  "上线的代码都是经过测试的"
	- 依赖导致原则
	  依赖抽象的好处就是新添加具体实现不用修改原来代码，参考DipTest.java
	  实际工作解释：gupaoedu-vip-spring-annotation -> com/gupaoedu/testAutowired/case1/A.java:7
	- 单一职责原则：
	  如果不单一那么增加新功能要修改原来代码：参考`TestCourse/NotSimpleCourse/`
	  单一职责意味着一个类只干一件事，当然这个也不能绝对有时拆的太细也不友好
	- 接口隔离
	  不接口隔离会有一大堆没用的代码
	  spring有很多接口（拆分成很多细的接口可以体会）
	- 迪米特
	  1. 看一下类结构图   不迪米特会怎么样：demeter，耦合度比较高维护比较困难
	- 里氏替换原则
	  先说一下里氏替换原则是啥？然后说到4个规则。
		- 我们再想一下什么有里氏替换原则为了解决什么问题？是为了当我们换成子类的时候代码跑起来依然没有问题？这是什么意思？找出代码来？
		- 四个原则具体指的是啥？
			- 思路：
			  Demo2TestMethodParam.java首先是重载然后是重写。注意重写是方法参数应该是一模一样。
			- 子类可以实现父类的抽象方法，但是不能替换父类的非抽象方法。
			  使用的方法实际功能跟它的名字不一样，特别在springboot开发中
			  `OpenCloseTest{
			  @Autowire
			  ICourse iCourse;
			  }`
			- 子类中可以增加自己特有的方法。
			- 为了防止由于重载和重写原因导致执行错误的方法（当我们替换成子类的时候，即Spring DI时候），约定一下两个原则：
				- 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松。
				  1. 执行Demo2TestMethodParam.java代码里写了注释，思路就是我预期调用什么方法实际调用什么方法。
				- 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输
				  出/返回值）要比父类更严格或相等。
		- 解释一下重载跟重写关系
			- 重载的加载顺序：
			  参考：https://blog.csdn.net/cowbin2012/article/details/89742407
			  执行testOverloadBind.Test_3()解释重载跟重写，这里涉及到运行时绑定和静态绑定。（上课时候让别人回过头来让别人知道我为什么解释运行时绑定和静态绑定）
		- 总结一下：
		  这样写代码会不会有问题
		  怎么解决：按照里氏替换原则，子类的参数要更宽松
		  背后逻辑：重载和重写
		  启示：以后写代码如果是新方法尽量取一个新的名字
	- 合成复用原则
	  继承是白盒
	  合成：黑盒compositereuse
- 给我们带来启示
  设计原则不是一个纯粹理论的而是一个经验的总结
  写嗲吗是给人来用的，要考虑实际人使用而不是追求花哨
  不要去比较单一职责和接口隔离区别只要知道工作中会用就行
-
	-
-
	-
-
-
-
	-
	-
-
-
-
-
-